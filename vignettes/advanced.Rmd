---
title: "Advanced usage"
author: "Patrick Schratz, Kirill Müller"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kirill Müller}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

old.hooks = fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE)
```

# Running stages conditionally

The conditioned execution of commands is based on environment variables.
The most common use cases are the testing on multiple R versions and the restriction of certain tasks that should only be executed once (e.g. the [deployment of a `pkgdown` site](deployment.html#pkgdown-deployment).
If you test on multiple CI services you may also want to run certain tasks on only one of them.

Take the execution of `covr::codecov()` as an example.
This call generates a coverage report of how much lines of a R package are covered by unit tests.
It has no benefit to run this on multiple R versions as the outcome will always be the same. 
Also it increases the build time on every build without adding value.
It is sufficient to just run it on one R version, e.g. "release".

When you use multiple R versions, Travis/Appveyor automatically set up a build matrix with each build having [set an environmental variable for the R version](https://docs.travis-ci.com/user/languages/r/#Environment-Variables) used.
So all you need to do is to condition the stage execution on this env variable:

```r
if ((getRversion() == "release")) {
  get_stage("after_success") %>%
    add_step(covr::codecov())
}
```

A special use case here would be to evaluate the R version inside an argument of `step_rcmdcheck()`.
Here, we set `warnings_are_errors = TRUE` for all R versions < v3.2.
Of course this only has an effect if testing on R versions < 3.2 is actually specified in `.travis.yml`.

```{r}
add_package_checks(warnings_are_errors = (getRversion() >= "3.2"))
```

Note that setting the `after_success` stage explicitly will simply append the commands to what `add_package_checks()` would do in the background for this particular stage.
So steps are not overwritten but incrementally added, even if specified multiple times.

Another condition that comes in handy is to run certain stages only on a specific CI service, e.g. Travis:

```r
if (inherits(ci(), "TravisCI") {
  get_stage("after_success") %>%
    add_step(covr::codecov())
}
```

And don't forget: All of these conditioning is specified in `tic.R`, which is a plain R file that is processed by simply calling `source()` on it.

# Installing packages

## Github packages

Github packages should be installed in the `install` stage:

```r
get_stage("install") %>%
  add_code_step(step_install_github("r-lib/rcmdcheck"))
```

Note that the underlying `remotes::install_github()` is vectorized for the `repo` argument which means you can pass all packages you want to install in a single function call: `add_code_step(step_install_github(c("r-lib/rcmdcheck", "r-lib/usethis"))`.

## CRAN packages

Sometimes you need to install CRAN packages that are not specified in the DESCRIPTION file of your package.
For example, to create a favicon in `pkgdown`, the `magick` package is required.
To install the package (only if it does not exist in the cache already), run the following:

```r
get_stage("install") %>%
  add_code_step(step_install_cran("magick"))
```

# Travis CI Meta-Information

The `ci()` function holds valuable information about the CI system. 
It can be used to query information that can be again be utilized for conditioning stages or steps.

For example, the user may wish to only deploy on Travis by using `inherits(ci(), "TravisCI")`:

```r
if (inherits(ci(), "TravisCI")) {
  get_stage("before_deploy") %>%
    add_step(step_setup_ssh())

  get_stage("deploy") %>%
    add_step(step_push_deploy())
}
```

See `?ci` for more information on which information can be extracted from this function.

# Troubleshooting: Running tic locally

You can run `tic` locally by using `load_from_file()`.
This function sources your `tic.R` file and reports eventual problems.

To emulate a CI run locally, you can simply call `tic()` and the stages and steps will be executed in your local R console.
Note that doing this will use your local system libraries and not the Travis environment.

# Troubleshooting: Entering the CI build

If your Travis build fails and you have no clue why (error messages are too unspecific, you cannot reproduce the problem locally), you can enter into the Travis build via `ssh`.
To do so, your repository must be [opt-in](https://docs.travis-ci.com/user/running-build-in-debug-mode/#enabling-debug-mode) for "ssh debugging".

Afterwards, you can simply call `travis::travis_debug_job(<jobID>)` and the build will restart.

Wait a few minutes until the build arrives at the point when it prints you the `ssh` command you can use to log in.
It should look similar to `ssh ukjiuCEkxBBnRAe32Y8xCH0zj@ny2.tmate.io`.

Once you are in the build [check](https://docs.travis-ci.com/user/running-build-in-debug-mode/#Things-to-do-once-you-are-inside-the-debug-VM) these handy functions to execute specific stages.

# What's not covered yet?

- `SystemRequirements`: `tic` is not yet capable of automatically determining system requirements specified in DESCRIPTION files of an R package. 
Our plan is to automatically provide suggestions like "Please add addons: apt: <library> to `.travis.yml`".
